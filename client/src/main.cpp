#include "irods/plugins/api/genquery2_common.h"

#include "irods/table_column_key_maps.hpp"

#include <irods/client_connection.hpp>
#include <irods/irods_at_scope_exit.hpp>
#include <irods/irods_exception.hpp>
#include <irods/procApiRequest.h>
#include <irods/rcMisc.h>     // For set_ips_display_name()
#include <irods/rodsClient.h> // For load_client_api_plugins()

#include <boost/program_options.hpp>
#include <fmt/format.h>

#include <algorithm>
#include <cstdlib>
#include <iostream>

auto print_usage_info() -> void;
auto print_columns_info() -> void;

int main(int _argc, char* _argv[]) // NOLINT(modernize-use-trailing-return-type)
{
	set_ips_display_name("iquery (experimental)");

	namespace po = boost::program_options;

	po::options_description desc{""};

	// clang-format off
	desc.add_options()
		("columns,c", po::bool_switch(), "")
		("query_string", po::value<std::string>()->default_value("-"), "")
		("sql-only", po::bool_switch(), "")
		("zone,z", po::value<std::string>(), "")
		("help,h", "");
	// clang-format on

	po::positional_options_description pod;
	pod.add("query_string", 1);

	load_client_api_plugins();

	try {
		po::variables_map vm;
		po::store(po::command_line_parser(_argc, _argv).options(desc).positional(pod).run(), vm);
		po::notify(vm);

		if (vm.count("help")) {
			print_usage_info();
			return 0;
		}

		if (vm["columns"].as<bool>()) {
			print_columns_info();
			return 0;
		}

		genquery2_input input{};

		if (vm.count("query_string") == 0) {
			fmt::print(stderr, "error: Missing QUERY_STRING\n");
			return 1;
		}

		auto query_string = vm["query_string"].as<std::string>();

		// Read from stdin.
		if ("-" == query_string) {
			query_string.clear();
			std::getline(std::cin, query_string);
		}

		if (query_string.empty()) {
			fmt::print(stderr, "error: Missing QUERY_STRING\n");
			return 1;
		}

		input.query_string = query_string.data();

		std::string zone;
		if (vm.count("zone")) {
			zone = vm["zone"].as<std::string>();
			input.zone = zone.data();
		}

		if (vm["sql-only"].as<bool>()) {
			input.sql_only = 1;
		}

		irods::experimental::client_connection conn;
		char* sql{};
		irods::at_scope_exit free_sql{[&sql] {
			if (sql) {
				std::free(sql);
			}
		}};

		const auto ec =
			procApiRequest(static_cast<RcComm*>(conn),
		                   IRODS_APN_GENQUERY2,
		                   &input,
		                   nullptr,
		                   reinterpret_cast<void**>(&sql), // NOLINT(cppcoreguidelines-pro-type-reinterpret-cast)
		                   nullptr);

		if (ec != 0) {
			fmt::print(stderr, "error: {}\n", ec);
			return 1;
		}

		fmt::print("{}\n", sql);

		return 0;
	}
	catch (const irods::exception& e) {
		fmt::print(stderr, "error: {}\n", e.client_display_what());
	}
	catch (const std::exception& e) {
		fmt::print(stderr, "error: {}\n", e.what());
	}

	return 1;
} // main

auto print_usage_info() -> void
{
	fmt::print(R"_(iquery - Query the iRODS Catalog

Usage: iquery [OPTION]... QUERY_STRING

Queries the iRODS Catalog using GenQuery2.

QUERY_STRING is expected to be a string matching the GenQuery2 syntax. Failing
to meet this requirement will result in an error.

If QUERY_STRING is a hyphen (-) or is empty, input is read from stdin. Input
taken via stdin will be viewed as the QUERY_STRING to execute. For example:

    echo select COLL_NAME, DATA_NAME | iquery

Mandatory arguments to long options are mandatory for short options too.

Options:
  -c, --columns         List columns supported by GenQuery2.
      --sql-only        Print the SQL generated by the parser. The generated
                        SQL will not be executed.
  -z, --zone=ZONE_NAME  The name of the zone to run the query against. Defaults
                        to the local zone.
  -h, --help            Display this help message and exit.
)_");

	char name[] = "iquery (experimental)";
	printReleaseInfo(name);
} // print_usage_info

auto print_columns_info() -> void
{
	// Capture the size of the longest GenQuery2 column.
	const auto& cmap = irods::experimental::api::genquery::column_name_mappings;
	const auto iter = std::max_element(std::begin(cmap), std::end(cmap), [](const auto& _lhs, const auto& _rhs) {
		return _lhs.first.size() < _rhs.first.size();
	});

	// Print information about each column.
	std::for_each(std::begin(cmap), std::end(cmap), [w = iter->first.size()](const auto& _v) {
		if (_v.second.table.empty()) {
			fmt::print("{:{}} (derived)\n", _v.first, w);
			return;
		}

		fmt::print("{:{}} ({}.{})\n", _v.first, w, _v.second.table, _v.second.name);
	});
} // print_columns_info
