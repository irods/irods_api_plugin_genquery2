#include "irods/plugins/api/genquery2_common.h"

#include <irods/client_connection.hpp>
#include <irods/irods_exception.hpp>
#include <irods/procApiRequest.h>
#include <irods/rcMisc.h>     // For set_ips_display_name()
#include <irods/rodsClient.h> // For load_client_api_plugins()

#include <boost/program_options.hpp>
#include <fmt/format.h>

#include <cstdlib>

auto print_usage_info() -> void;

int main(int _argc, char* _argv[]) // NOLINT(modernize-use-trailing-return-type)
{
#ifdef IRODS_ENABLE_42X_COMPATIBILITY
	setenv(SP_OPTION, "iquery (experimental)", /* overwrite */ 1);
#else
	set_ips_display_name("iquery (experimental)");
#endif // IRODS_ENABLE_42X_COMPATIBILITY

	namespace po = boost::program_options;

	po::options_description desc{""};

	// clang-format off
	desc.add_options()
		("query_string", po::value<std::string>(), "")
		("sql-only", po::bool_switch(), "")
		("zone,z", po::value<std::string>(), "")
		("help,h", "");
	// clang-format on

	po::positional_options_description pod;
	pod.add("query_string", 1);

	load_client_api_plugins();

	try {
		po::variables_map vm;
		po::store(po::command_line_parser(_argc, _argv).options(desc).positional(pod).run(), vm);
		po::notify(vm);

		if (vm.count("help")) {
			print_usage_info();
			return 0;
		}

		genquery2_input input{};

		if (vm.count("query_string") == 0) {
			fmt::print(stderr, "error: Missing QUERY_STRING\n");
			return 1;
		}

		auto query_string = vm["query_string"].as<std::string>();
		input.query_string = query_string.data();

		std::string zone;
		if (vm.count("zone")) {
			zone = vm["zone"].as<std::string>();
			input.zone = zone.data();
		}

		if (vm["sql-only"].as<bool>()) {
			input.sql_only = 1;
		}

		irods::experimental::client_connection conn;
		char* sql{};

		const auto ec =
			procApiRequest(static_cast<RcComm*>(conn),
		                   IRODS_APN_GENQUERY2,
		                   &input,
		                   nullptr,
		                   reinterpret_cast<void**>(&sql), // NOLINT(cppcoreguidelines-pro-type-reinterpret-cast)
		                   nullptr);

		if (ec != 0) {
			fmt::print(stderr, "error: {}\n", ec);
			return 1;
		}

#ifdef IRODS_ENABLE_42X_COMPATIBILITY
		(1 == input.sql_only) ? fmt::print("{}\n", sql) : fmt::print(sql);
#else
		(1 == input.sql_only) ? fmt::print("{}\n", sql) : fmt::print(fmt::runtime(sql));
#endif // IRODS_ENABLE_42X_COMPATIBILITY

		std::free(sql);

		return 0;
	}
	catch (const irods::exception& e) {
		fmt::print(stderr, "error: {}\n", e.client_display_what());
	}
	catch (const std::exception& e) {
		fmt::print(stderr, "error: {}\n", e.what());
	}

	return 1;
} // main

auto print_usage_info() -> void
{
	fmt::print(R"_(iquery - Query the iRODS Catalog

Usage: iquery [OPTION]... QUERY_STRING

Queries the iRODS Catalog using GenQuery2.

QUERY_STRING is expected to be a string matching the GenQuery2 syntax. Failing
to meet this requirement will result in an error.

Mandatory arguments to long options are mandatory for short options too.

Options:
      --sql-only        Print the SQL generated by the parser. The generated
                        SQL will not be executed.
  -z, --zone=ZONE_NAME  The name of the zone to run the query against. Defaults
                        to the local zone.
  -h, --help            Display this help message and exit.
)_");

	char name[] = "iquery (experimental)";
	printReleaseInfo(name);
} // print_usage_info
